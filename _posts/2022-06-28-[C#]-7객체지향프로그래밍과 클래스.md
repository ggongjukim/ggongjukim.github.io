---
title : "[C#]3. 데이터를 담는 변수와 상수"
layout: single
categories : C#
tag : [C#]
toc : true
---
### 출처 :exclamation:
- 본 내용은 C# 공부 내용이며 책과 [강의](https://www.youtube.com/playlist?list=PLVsNizTWUw7Eye-a7CY7f1zeLWJNWe163)를 정리한 내용입니다

*************************
## 강의 목표
- 클래스와 객체
  - 클래스 선언과 객체의 생성
  - 생성자와 종료자
  - this 키워드
  - 접근한정자
  - 상속과 오버라이딩
- 구조체
- 튜플

*************************
<br>
<br>
<br>


# 객체 지향 프로그래밍
코드 내의 모든 것을 **객체(Object)로 표현**하고자 하는 프로그래밍 패러다임(생각)  
객체는 **데이터(속성) 과 기능(메소드)**로 이루어짐     
이전까지의 내용으로는 절차적 프로그래밍 패러다임으로 코딩 가능       
  - 절차적 프로그래밍 : 코드의 순차적인 실행
  - 객체지향 프로그래밍 : 객체간의 상호작용

<br>
<br>
<br>

# 클래스와 객체의 관계
클래스는 객체를 만들기 위한 청사진(설계도)      
데이터 형식과 변수와의 관계와 동일하다           

| 클래스 | 객체 | 
|---|---|
|설계도|**메모리에 적재된 실체**|
|각 클래스 별로<br> **하나만 존재**|여러개 만들수 있음 <br> **무한생성가능** <br> 메모리 차지|
|객체가 어떤 데이터 항목을 <br> 가질지 **정의**|정의된 데이터 항목의 실제 데이터를 저장|
|**어떤 메소드를 가질지 정의**|정의된 메소드 실행|
|변수 필드 메소드|속성(데이터)과 기능(메소드)|
|변수 필드| 속성 데이터|
|메소드|메소드|


<br>
<br>
<br>

## | 클래스 선언
**클래스 내부에 선언**  
class 키워드      
**클래스의 변수** 로 **객체의 속성(데이터)** 을 표현   
**클래스의 변수**는 **필드**라고 부른다     
c++에서는 **클래스의 변수**를 **멤버변수**라고 한다   
**클래스의 메소드** 로 **객체의 기능(메소드)** 표현

```c#
class Cat
{
  public string Name; 필드
  public string Color; 필드

  public void Meow() 메소드
  {
    ...
    return 메소드결과;
  }
  
}

```

<br>

### | 객체 생성
```new``` 연산자와 **생성자** 이용       
객체의 멤버(필드 및 메소드 등)에 접근할 때는 ```.```연산자 사용

```
[객체 생성 VS 변수 생성]
변수는 데이터 형식을 적어주고 식별자를 적어주면 완료
객체를 생성할떄는 new 연산자와 생성자가 필요하다
```

```c#
Cat kitty = new Cat(); new 연산자를 실행하면서 생성자를 호출
kitty.Color = "하얀색"; 그러면 객체를 이용해서 필드와 메소드에 접근을 할 수 있음
kitty.name = "키티"; 
```

<br>


### | 생성자와 종료자
클래스는 생성자와 종료자라는 특별한 메소드를 가짐         
생성자 : 객체가 생성될때 호출       
  - 반환형식이 없음 
  - 필드 초기화, 자원 초기화 같은 작업이 이루어진다
  - 자원 : 파일 or 네트워크 커넥션 or DB 커넥션 등 .. 이런걸 말함
 
종료자 : 객체가 소멸될때 호출        
  - 매게변수도 없고 클래스 앞에 ```~```표시가 있음
  - 생성된 자원을 정리하는 역할
  - 소멸자가 호출된 시점을 알 수가 없다 가비지컬렉터가 소멸자로 호출하기 때문에

생성자와 종료자를 프로그래머가 직접 구현하지 않으면 컴파일러가 기본 구현을 제공함         
그래서 써도 되고 안써도 됨 선택사항      

```c#
class 클래스이름
{
  한정자 클래스이름( 매게변수목록) 생성자 반환형식이 없음
  {
    //
  } 
  클래스이름(){ 종료자

  }
}
```

<br>


### | 생성자 오버로딩
생성자도 오버로딩을 할 수 있다        
객체의 필드를 초기화하는 다양한 옵션 제공 가능        

```c#
class Cat
{
  public Cat(){  
      Name ="";
      Color ="";
  }
  
  public Cat(string _Name, string _Color){
    Name = _Name;
    Color = _Color;
  }
  public string Name; //필드
  public string Color; //필드
}

```

```c#
Cat kitty = new Cat(); // 첫번째 생성자 호출
kitty.Name = "키티";
kitty.Color = "하얀색"

Cat nabi = new Cat("나비", "갈색"); // 두번째 생성자 호출

다양한 방법으로 객체의 필드( 속성, 데이터)를 호출 할 수있게 한다.
```

<br>


### | this 키워드 :star:
객체를 사용하는 코드에서 참조로 객체를 지칭함        
>ex.        
>```Cat nabi = new Cat();``` 에서 ```nabi```는 ```new Cat()```을 통해 생성된 객체를 지칭함      
> **복합데이터형식**은 힙에 **할당** 이 된다     
>그리고 스택의 참조를 이용하여서 힙의 내용을가리키게 된다       
>```nabi```가 참조임 

```this```는 객체 내부에서 자신을 지칭할때 사용하는 키워드      
```base```는 부모클래스를 나타내는 참조

```c#
class Employee
{
  private string Name;
  public void SetName(string Name)
  {
    this.Name = Name;
  }
}
``` 

<br>


### | 접근 한정자
필드 메소드 프로퍼티 등 객체 멤버에 대해 외부에서 어떻게 접근이 가능한지 또는 접근이 불가능한지를 수식해주는 한정자         
각 객체는 다른 객체에게 자신의 내부사정(필드 메소드 프로퍼티)을 공개하지 않는다
다른 객체에게 공유해야만 하는 멤버만 접근한정자를 이용하여 공개

| public | 외부와 내부에서 접근 가능 | 
|---|---|
| protected | 외부에서 접근 불가 <br> 파생클레스 가능| 
| private | 내부에서만 접근 가능 <br> 그외 불가능 | 

<br>

**************
<br><br>



### | 상속
객체지향 프로그래밍에서는 어떤 클래스가 다른 클래스를 상속 받을 수 있다.       
다른 클래스로부터 코드를 물려받음       
클래스의 멤버를 물려줌      
부모클래스(기반클래스) - > 자식클래스(파생클래스)      
```class 자식클래스 : 부모클래스``` 하면 상속이 됨 

<br>


### | 오버라이딩 :star:
**기반클래스에서 선언된 메소드를 자식클래스에서 재정의 하는것**        
기반클래스에서 오버라이딩이 될 메소드를 미리 지정해놓고  ```virtual```로 한정한다

```c#
class A{
  public virtual void init(){ //virtual이 있으면 A클래스는 부모클래스가 된다는 것을 암시
    //
  }
}

class B : A{
  public overrride void Init(){
    base.Init() // 부모클래스의 메소드 실행
    //
  }
}
```
<br><br><br>


***************
<br>

### | 구조체
구조체는 클래스와 같은 복합 데이터 형식        
```struct```를 사용하여 선언       
클래스 VS 구조체        
  |클래스 | 구조체|
  |---|---|
  |참조형식|**값형식**|
  |클래스의 인스턴스는 <br>힙에 올라감 | 스택에 올라감|
  |가비지콜렉터가 제거|스택은 자동 메모리이기 때문에 <br> 스택이 자동으로 제거 |

```c#
struct 구조체 이름{
  // 필드
  // 메소드
}
```
<br><br><br>

### | 튜플
튜플은 기본적으로 구조체임 즉 **값형식**         
형식 이름없이 선언하여 사용      

```
[구조체가 있는데 굳이 튜플을 따로마는 이유?]
튜플은 형식이름을 부여하지 않고 선언하는 복합 데이터 형식
이름이 없으니, 여러번 사용할 일이 없을때 주로 사용
즉석에서 활용되는 형식
프로그램 전역에서 사용할 형식에는 부적합 하다!
그럴때는 클래스나 구조체가 적합!
var 형식을 쓴다 : 튜플에 담겨질 값의 목록을 보고 컴파일이 형식을 추론할 수 있도록
```

```c#
var tuple = (123,789)
```